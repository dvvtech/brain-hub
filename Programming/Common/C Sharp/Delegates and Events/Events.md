
### События:

- **Событие** — это поле класса или интерфейса, который обеспечивает механизм для обработки событий. События используют делегаты в качестве своей основы, определяя тип делегата, который используется для обработки события.
- События — это способ класса или объекта предоставлять уведомления другим классам или объектам, когда происходит что-то важное.
- События могут быть "подписаны" с помощью делегатов. Классы, подписывающиеся на события, добавляют методы-обработчики, которые будут вызываться, когда класс, владеющий событием, его "публикует" или "вызывает".
- События обеспечивают уровень защиты: они могут быть вызваны только из класса, который их определяет. Внешние классы могут подписываться на события и отписываться от них, но не могут напрямую вызвать событие.

В общем, делегаты — это безопасный тип в отношении типов способ взаимодействия с методами, в то время как события используют делегаты для уведомления о том, что произошло что-то важное, позволяя другим объектам реагировать на эти уведомления.

```csharp
public delegate void EventHandler(string message);

public class MyClass
{
    public event EventHandler MyEvent;

    public void TriggerEvent()
    {
        if (MyEvent != null)
        {
            MyEvent("Событие сработало!");
        }
    }

	//Потокобезопасная версия
	public void TriggerEvent()
	{
	    //присваивание ссылки на делегат
	    EventHandler handler = MyEvent;
	    if (handler != null)
	    {
	        handler("Событие сработало!");
	    }
	}

}
```

Когда вы объявляете событие в C# с использованием ключевого слова `event`, компилятор создает для этого события закрытый (private) делегат и пару открытых методов `add` и `remove` для управления подписчиками этого события. Эти методы используются для добавления и удаления обработчиков событий.

Допустим, у вас есть следующее объявление события:

```csharp
public event EventHandler MyEvent;
```

Компилятор C# преобразует это объявление примерно в следующий код (упрощенная форма):

```csharp
private EventHandler _myEvent;

public event EventHandler MyEvent
{
    add
    {
        _myEvent += value;
    }
    remove
    {
        _myEvent -= value;
    }
}
```

В этом преобразованном коде:

- `_myEvent` — это закрытый делегат, который фактически хранит список подписчиков на событие.
    
- `add` — это метод, который вызывается, когда обработчик добавляется к событию (через оператор `+=`). `value` в этом контексте представляет добавляемый делегат.
    
- `remove` — это метод, который вызывается, когда обработчик удаляется из события (через оператор `-=`). Опять же, `value` представляет удаляемый делегат.
    

Эта инкапсуляция делегата внутри свойств `add` и `remove` обеспечивает больший контроль над тем, как обработчики добавляются и удаляются, и предотвращает внешний доступ, который мог бы нарушить список подписчиков.

Кроме того, подход с использованием `add` и `remove` обеспечивает возможность для дополнительной логики внутри этих аксессоров, например, для безопасности потоков или для выполнения дополнительных действий при подписке или отписке от события.

События нельзя объявить внутри метода они могут быть объявлены только как поле класса.

Например у нас объявлено событие в классе и это событие вызывается при определенном состоянии класса. Если мы у этого события уберем ключевое слово event, все также продолжит правильно работать. Но нарушится инкапсуляция этого события. Так как теперь любой внешний класс может вызвать событие(по факту делегат) и присваивать ему значения напрямую например присвоить null. И теряется гарантия что событие может вызваться только изнутри класса.


```csharp
public class TickerService
{
	public event EventHandler<MyEventArgs> Ticked;

	public void OnTick(TimeOnly time)
	{
		Ticked?.Invoke(this, new TickerEventArgs(time));
	}
}

public class TickerEventArgs
{
	public TimeOnly Time { get; }

	public MyEventArgs(TimeOnly time)
	{
		Time = time;
	}
}
```