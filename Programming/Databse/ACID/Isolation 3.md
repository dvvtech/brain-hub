1. **Read Uncommited (Dirty read)**
### Сценарий

- **Транзакция 1** (T1) начинается и читает данные.
- **Транзакция 2** (T2) начинается после начала T1, изменяет те же данные, но не фиксирует их.
- **T1** снова читает те же данные и на этот раз видит незафиксированные изменения, сделанные T2.

1. **Read Comited (дефолтный)** 
### Сценарий

- **Транзакция 1** (T1) начинается и читает данные.
- **Транзакция 2** (T2) начинается после начала T1, изменяет те же данные и фиксирует изменения.
- **T1** снова читает те же данные и на этот раз видит изменения, внесенные T2.

А если T2 изменяет данные но не успевает зафиксироваться то T1 при обращении к тем же данным не увидит изменения

3. **Reapeatable Read**
### Сценарий

Рассмотрим сценарий, где две транзакции работают с одной и той же таблицей в базе данных.

- **Транзакция 1** (T1) начинается и читает данные.
- **Транзакция 2** (T2) начинается после начала T1, изменяет те же данные и фиксирует изменения.
- **T1** снова читает те же данные и видит результаты, идентичные первому чтению, несмотря на изменения, внесенные T2.

Но если T2 добавила строки то T1 при повторном запросе их увидит - это называется фантомное чтение

Также этот уровень изоляции следит за корректностью записи (например обновления) Тоесть если Т1 захочет сделать изменения в строке а Т2 опередила ее и закомитила то при выполнении Т1 получим ошибку concurrent update. И приложения должны ретраить упавшие транзакции.

4. **Seializable**
Полная изоляция
### Сценарий

- **Транзакция 1** (T1) начинается и читает данные.
- **Транзакция 2** (T2) начинается после начала T1 и пытается изменить данные. Однако, из-за уровня изоляции `Serializable`, T2 не может внести изменения(и не сможет добавить) до завершения T1.
- **T1** завершается, и только тогда T2 может продолжить свою работу.

Предотвращает фантомное чтение. Реализуется через блокировки

5. Snapshot
Уровень изоляции `Snapshot` обеспечивает каждой транзакции работу с собственным "снимком" данных, который был актуален в момент начала транзакции. Это значит, что транзакция видит данные в том состоянии, в котором они были, когда транзакция началась, независимо от изменений, внесенных другими транзакциями. Такой подход помогает избежать блокировок и конфликтов при одновременной работе нескольких транзакций.
### Сценарий

- **Транзакция 1** (T1) начинается и создает "снимок" данных.
- **Транзакция 2** (T2) начинается после начала T1 и изменяет некоторые данные, затем фиксирует их.
- **T1** продолжает работу и читает данные. T1 видит данные в том состоянии, в котором они были на момент её начала, несмотря на изменения, внесенные T2.

Защита от фантомного чтения

**Конфликты Записи**: Хотя блокировки чтения существенно уменьшены, транзакции все еще могут вступать в конфликт при попытке записи. Если две транзакции пытаются изменить одну и ту же строку, одна из транзакций может завершиться с ошибкой "конфликта обновления", если другая транзакция уже внесла изменения в эту строку и зафиксировала их.