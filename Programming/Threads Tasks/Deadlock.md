```cs
var a = new object();
var b = new object();

lock(a)
{
	lock(b)
	{
	}
}

lock(b)
{
	lock(a)
	{
	}
}
```

Deadlock - первый lock выполняет первый поток второй lock выполняет второй поток

Еще пример
Этот подход является синхронным ожиданием завершения задачи. Он может привести к проблеме "deadlock" (взаимной блокировки) в некоторых контекстах, особенно в однопоточных средах, таких как UI-приложения или ASP.NET. Взаимная блокировка возникает, когда контекст синхронизации, в котором выполняется `M().Result`, ожидает завершения задачи, но задача пытается вернуться в этот же контекст для своего выполнения.
Этот подход блокирует вызывающий поток до тех пор, пока задача не будет завершена.
```cs
async Task M()
{
	...
}
var res = M().Result
```
нужно так
```cs
//синхронное ожидание задачи без захвата контекста синхронизации
var res = M().ConfigureAwait(false).GetAwaiter().GetResult()
```

Этот подход также блокирует вызывающий поток, но уменьшает вероятность взаимной блокировки по сравнению с простым вызовом `.Result`.
В случае исключений, `GetAwaiter().GetResult()` выбрасывает исходное исключение, в то время как `.Result` оборачивает его в `AggregateException`.