При одновременном доступе к разделяемому ресурсу(например бд) вызывает состояние гонки и блокировки призваны решить эту проблему.
Как избежать гонки? 
 - Потоку выдается эксклюзивный доступ к ресурсу.(lock)
 - Lock - free алгоритмы. Как пример можно исключить общий ресурс и делать копии с новыми значениями. И каждый поток будет работать с своим экземпляром переменной

Виды потоков
1. Аппаратный поток(логическое ядро)
Равен кол-ву ядер процессора. При hyper-threading может быть несколько потоков (или логич. ядер).
![[Pasted image 20240213205422.png]]
У логич. ядер могут быть конкуренция за общие ресурсы ввиде физического ядра. Эту конкуренцию разрешает сам процессор.
На логических ядрах не происходит удвоение скоростей.
И ОС воспринимает и работает именно с физическими ядрами.
Например процессор 14 ядер и 20 потоков. ОС будет видеть 20 потоков. 20 потоков это 20 логических ядер.
2. Поток выполнения (Поток). - контекст который позволяет процессору выполнять набор инструкций
Потоками управляет ОС. Она их создает, уничтожает, планирует.
На одном логическом ядре может запускаться несколько потоков выполнения.

На компе обычно работают около 2500 потоков. Основная их часть просто висит в ожидании(ждет событий).
Каждому потоку выделяется свое процессорное время.
Макс. кол-во потоков в теории не ограничено.

Состояния потока: готовность, выполнение, ожидание, приостановлен, возобновлен, завершен.

когда вы вызываете `Thread.Sleep` в .NET, поток, из которого был сделан вызов, переходит из состояния "Выполнение" (Running) в состояние "Ожидание" (WaitSleepJoin). Это состояние указывает, что поток был явно остановлен на заданный период времени и не использует процессорные ресурсы.

`Thread.SpinWait` используется для создания занятого ожидания (busy-waiting). Вместо того чтобы переводить поток в состояние ожидания, поток активно проверяет условие в течение очень короткого времени, что может быть эффективно в сценариях с ожиданием недолгих операций.
Использование `Thread.SpinWait` может увеличить производительность в многопоточных приложениях, где потоки часто блокируются на короткое время, поскольку избегает затрат на переключение контекста. Однако, неправильное использование может привести к излишнему потреблению процессорного времени и снижению общей производительности приложения.

Foreground процесс остановится только после остановки всех Foreground потоков.
При остановке процесса все background потоки принудительно закрываются.

thread это низкоуровневая логика и сейчас в основном используются таски

создание thread это дорогая операция

таски больше про асинхронность а не про многопоточность.
асинхронность может работать в однопоточной среде.
таски решают больше вопрос о том как не ждать (не висеть в блокировке) пока не закончится операция

![[Pasted image 20240226124230.png]]
Mutex-это блокировка уровня ядра. (когда несколько экземпляров поднято приложения и они используют общий ресурс)
Блокировки режима ядра обходятся дорого(деградация производительности). Уходит много времени на обращениие к режиму ядра.
Если mutex именнованный то он действует на уровне ОС для блокировок между процессами
иначе действует в рамках одного процесса. 
Поток получения и снятия блокировки должен быть одним и темже

Semaphore (используется для ограничения уровня параллелизма, приходит куча реквестов и мы делаем ограничение на кол-во одновременнных запросов)
Содержит в себе счетчик. release увеличивает число в счетчике а Wait понижает
Если счетчик понижается до 0 то при вызове Wait поток уходит в блокировку(засыпает) пока счетчик не увеличится
Не захватывает поток и wait и Release могут быть вызваны из разных потоков

![[Pasted image 20240226130935.png]]

тут больше 4 не выведется
![[Pasted image 20240227185730.png]]



В одноядерных системах пользовательские блокировки бесполезны. Они сразу делают Thread.Yield - отдает время другому потоку

Работа с блокировками ядра обходится дороже чем отдать
Thread.Yield легковесная операция