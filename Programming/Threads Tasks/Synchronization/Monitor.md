![[Pasted image 20231212175831.png]]
Усыпляем поток если очередь пуста. Это альтернатива Thread.Sleep(x)
И в методе где добавляется _actions написать
if(_actions.Count == 1)
{
	Monitor.Pulse(_syncRoot);//поток проснется
}

lock(obj) разворачивается в такую конструкцию

```csharp
object obj = new object();

Monitor.Enter(obj);
try
{
    // Защищенный код, к которому в один момент времени может обращаться только один поток.
}
finally
{
    Monitor.Exit(obj);
}
```

### Принцип работы

1. **Блокировка объекта**: При вызове `Monitor.Enter(obj)`, текущий поток пытается получить блокировку на объекте `obj`. Если объект уже заблокирован другим потоком, текущий поток будет приостановлен до тех пор, пока блокировка не будет освобождена.

Есть таблица блоков синхронизации(sync block) которая хранит запись о состоянии блокировки объекта и потоке, владеющем блокировкой.
И в заголовке объекта есть индекс на эту таблицу. А сама таблица не хранится в куче а хранится в отдельной области памяти

Попытка получения блокировки: Когда поток пытается получить блокировку на объекте с помощью Monitor.Enter(obj) или lock(obj):

    Если объект не заблокирован, CLR отмечает объект как заблокированный для этого потока, обновляя соответствующую запись в таблице блоков синхронизации.
    Если объект уже заблокирован другим потоком, поток, пытающийся получить блокировку, приостанавливается и помещается в очередь ожидания до тех пор, пока блокировка не будет освобождена.

Освобождение блокировки: Когда Monitor.Exit(obj) вызывается (автоматически в конце блока lock), CLR освобождает блокировку, обновляя информацию в таблице блоков синхронизации и, если есть потоки, ожидающие блокировку этого объекта, разблокирует один из них.