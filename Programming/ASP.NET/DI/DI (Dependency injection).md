Чтоб зависимости создавал DI. Так как для создания зависимости нужно передать несколько параметров. И не удобно в разных местах это создавать. Мы в одном месте создаем и регаем эту зависимость а потом в любом месте можем получть ее.
Основная идея DI состоит в том, что класс не должен самостоятельно создавать или искать необходимые ему зависимости (например, сервисы или компоненты). Вместо этого эти зависимости предоставляются ему извне, чаще всего через конструктор, метод или свойства.

#### Пример Dependency Injection:
```csharp
public class UserController {
    private IUserService _userService;

    // Инъекция через конструктор
    public UserController(IUserService userService) {
        _userService = userService;
    }
}
```

- DI - это паттерн который позволяет внедрять зависимости в классы из вне.
- Уменьшаются зависимости между классами. Например класс А использует класс B. Классу А не нужно знать как проинициализировать класс B. И код становится чище
- Проще тестировать
- Низкая связанность кода
- Контроль времени жизни объекта
- Высокая степень модульности. Если мы меняем конструктор зависимости нам не нужно что-то менять в местах где он используется а только в одном месте.

DI это один из принципов SOLID.
Сам DI работает на DI Container - это объект который умеет создавать классы.
Позволяет один раз писать код, который создает наши объекты
Настраивается в методе ConfigureServices
Умеет понимать какие объекты нудно создавать и поместить в конструктор вашего объекта.

IServiceCollection - представляет DI Container, добавляем зависимости
IServiceProvider - представляет созданный DI Container, из которого можно получать зависимости, зарегистрированные в IServiceCollection
у IServiceProvider есть метод GetService (если зависимость не найдена то возвращает null)
        и метод GetRequiredService (если зависимость не найдена то бросает исключение)
        лучше GetRequiredService

3 метода регистрации зависимостей в DI Container
 * AddSingleton
 **Использование**: Используйте для сервисов, которые являются потокобезопасными и не сохраняют состояние, зависимое от конкретного запроса или пользователя.
 
 * AddScoped
 **Использование**: Используйте Scoped для сервисов, которые содержат состояние в рамках одного запроса и не должны использоваться в других контекстах.
 
 * AddTransient
Используйте Transient для сервисов, которые легкие и не хранят состояние между запросами.

AddTransient используется если не содержит состояния или содержит состояние но оно должно быть изолировано от других взаимодействий.

![[Pasted image 20240111211053.png]]

Если в сервисе как singleton передадим сервис как transient то этот второй сервис будет singleton

контроллеры созданы как scoped

Фоновая job, которая что-то делает раз в 5 мин. Создаем эту job раз в 5 мин чтобы она что-то делала.

Если в контроллер приходят 2 одинаковых сервиса зареганых как Scoped то по факту это будут 2 одинаковых ссылки


