Давайте сразу начнем с примера. Например у нас есть объект Person и он у нас будет использоваться как ключ при добавлении в Dictionary. Соответственно нам нужно будет реализовать метод GetHashCode() и для генерации хеш кода в демонстрационных целях мы завяжемся только дату рождения. В реальной ситуации лучше использовать все поля для генерации хеш кодов.

Отображать текст кода не сразу а постепенно

```cs
class Person
{
    public string Name { get; set; }
    public DateTime DateOfBirth { get; set; }

    public override bool Equals(object obj)
    {
        return obj is Person person &&
               Name == person.Name &&
               DateOfBirth == person.DateOfBirth;
    }

    public override int GetHashCode()
    {        
        return DateOfBirth.GetHashCode();
    }
}


class Program
{
    static void Main()
    {
        var dictionary = new Dictionary<Person, string>(5);

        var person1 = new Person { Name = "Алексей", DateOfBirth = new DateTime(1985, 5, 22) };
        var person2 = new Person { Name = "Марина", DateOfBirth = new DateTime(1990, 8, 14) };
        // Представим, что Игорь родился в тот же день, что и Алексей.
        var person3 = new Person { Name = "Игорь", DateOfBirth = new DateTime(1985, 5, 22) };

        dictionary.Add(person1, "Работает инженером");
        dictionary.Add(person2, "Работает дизайнером");
        dictionary.Add(person3, "Работает архитектором");

        
    }
}
```

Добавляем первый элемент в коллекцию. Что у нас происходит внутри Dictionary. А внутри у нас 2 массива `int[] buckets` и `Entry[] entries`. И при добавлении у нас происходит вычисление хеш кода
uint hashCode = key.GetHashCode();
далее вычисляем индекс массива buckets
int bucketIndex = hashCode % buckets.Length;
Далее само значение добавляется в  массив `entries` и важно что все последующие значения добавляются в этот массив последовательно.
Берем индекс добавленного элемента в массиве entries и сохраняем его в массиве buckets по индексу bucketIndex.
При добавлении второго элемента все повторяется.
При добавлении третьего элемента оказывается что bucketIndex будет такой же как у первого элемента


```cs
private struct Entry
{
    public TValue value;
    public TKey key;
    public int hashCode;
    public int next;    
}
```

Давайте разберёмся, как они работают:
узнать размер buckets и entries
и немного заглядывать в реализацию Dictionary в исходники

пример с диктионари с добавлением эл-та
и далее отображаю схему что происходит
первые 2 элемента например например дают разный хешкод и следующий такойже как у первого элемента.

Для ключа такого


Элементы в `entries` добавляются последовательно по мере их вставки в словарь. Однако, связь между элементами одной "корзины" поддерживается через индекс следующего элемента в цепочке, который указан в каждом `Entry`. Это позволяет элементам с одинаковым индексом `buckets` быть связанными в список, несмотря на то, что они физически могут располагаться в разных частях массива `entries`.

Массив `entries` содержит все элементы словаря. Каждый элемент в этом массиве — это структура, которая включает ключ, значение, хеш-код ключа и индекс следующего элемента в цепочке для данной "корзины".

Если два разных ключа дают после модуля размера `buckets` один и тот же индекс, они попадут в одну "корзину" и будут формировать связный список (цепочку) в массиве `entries`.

Внутреннее устройство `Dictionary<TKey, TValue>` в .NET реализовано как хеш-таблица, которая использует массив для хранения данных и обеспечивает быстрый доступ к элементам по ключу. Основная идея состоит в том, чтобы использовать хеш-функцию для преобразования ключа в индекс массива, по которому затем можно быстро найти или сохранить соответствующее значение.
**Хеш-коды**: Когда элемент добавляется в `Dictionary`, для его ключа вычисляется хеш-код с использованием метода `GetHashCode()`. Хеш-код представляет собой целое число, которое используется для определения позиции элемента в массиве.

Внутренне `Dictionary` использует, как минимум, два массива — один для хранения хеш-кодов (или индексов, вычисленных на их основе), и второй для хранения самих элементов (`Entry[]`), где каждый элемент содержит ключ, значение и указатель на следующий элемент в цепочке (для разрешения коллизий).
**Структура `Entry`**: Элементы словаря хранятся в массиве как структуры или объекты, содержащие ключ, значение и индекс следующего элемента в цепочке для данного индекса массива. Это обеспечивает возможность разрешения коллизий и поддержание связного списка элементов, которые попадают в один и тот же индекс массива.

```cs
private struct Entry
{
    public TValue value;
    public TKey key;
    public int hashCode;
    public int next;    
}
```

При добавлении элемента вычисляется хэшкод его ключа и затем — индекс корзины в которую он будет добавлен по модулю от величины коллекции:

```cs
int bucketNum = (hashcode & 0x7fffffff) % capacity;
```


5. **Ресайзинг**: Когда фактор заполнения `Dictionary` (отношение количества элементов к размеру массива) достигает определенного порога, происходит автоматическое увеличение размера внутреннего массива и перехеширование элементов. Это необходимо для поддержания высокой производительности операций доступа к элементам.
    
6. **Перехеширование**: При ресайзинге каждый элемент перехешируется с учетом нового размера массива, чтобы обеспечить равномерное распределение элементов по массиву и минимизировать количество коллизий.